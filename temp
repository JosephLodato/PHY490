void calculateCenter(vector<array<double, 2>> points, double dT)
{
    // this must do the integral section of the equation
    // for visualizing it we must multiply my 1 / (t2-t1)
    // this gets dropped later

    int n = points.size();
    complex<double> integral(0.0, 0.0);

    // First and last points
    complex<double> first(points[0][0], points[0][1]);
    complex<double> last(points[n - 1][0], points[n - 1][1]);

    // Apply the trapezoidal rule
    integral += first + last;

    for (int i = 1; i < n - 1; i++)
    {
        complex<double> current(points[i][0], points[i][1]);
        integral += 2.0 * current;
    }

    integral *= (dT / 2.0);

    // Calculate the magnitude (r)
    double r = abs(integral);

    // Calculate the argument (theta)
    double theta = arg(integral);

    // Calculate the x/y coordinate in polar form
    double x_polar = r * cos(theta);
    double y_polar = r * sin(theta);

    printf("c %f %f 0.1 \n", x_polar, y_polar);
}

void DFT(double f, double t, double tStop, double dT)
{
    vector<array<double, 2>> points;

    while (t < tStop)
    {
        t += dT;
        points.push_back(finalCalculation(f, t));
    }

    // display all points
    for (int i = 0; i < points.size(); i++)
    {
        printf("c %f %f 0.01\n", points[i][0], points[i][1]);
    }

    // find the "center of mass 'points' "
    // calculateCenter(points, dT);

    printf("l -2 0 2 0\n");
    printf("l 0 -2 0 2\n");
    printf("t -2 2 \n Wrapping Frequency: %f \n", f);

    printf("F\n");
    points.clear();
}